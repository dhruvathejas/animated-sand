{"entries":[{"timestamp":1743828369286,"editorVersion":"2.0.48","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":216,"length1":115,"diffs":[[1,"    \"preferredEditor\": \"blocksprj\",\n    \"languageRestriction\": \"no-blocks\",\n    \"additionalFilePaths\": []\n"]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"},{"type":"added","filename":"main.blocks","value":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"}]}],"snapshots":[{"timestamp":1743828369285,"editorVersion":"2.0.48","text":{"main.ts":"// Animated LED sand ported from\n// https://learn.adafruit.com/animated-led-sand/code\n\nconst N_GRAINS = 80;\nconst grainImg = img`\n    b b b b b b b .\n    b d d d d d b .\n    b d d d d d b c\n    b d d d d d b c\n    b d d d d d b c\n    b d d d d d b c\n    b b b b b b b c\n    . . c c c c c c\n`;\nconst GRAIN_RADIUS = grainImg.width;\nconst WIDTH = Math.idiv(screen.width, GRAIN_RADIUS); // Display width in pixels\nconst HEIGHT = Math.idiv(screen.height, GRAIN_RADIUS); // Display height in pixels\n\n// The 'sand' grains exist in an integer coordinate space that's 256X\n// the scale of the pixel grid, allowing them to move and interact at\n// less than whole-pixel increments.\nconst MAX_X = (WIDTH * 256 - 1); // Maximum X coordinate in grain space\nconst MAX_Y = (HEIGHT * 256 - 1); // Maximum Y coordinate\nclass Grain {\n    constructor(public x: number, public y: number, public vx: number, public vy: number)\n    { }\n}\nconst grain: Grain[] = [];\nconst imgbuf = control.createBuffer(WIDTH * HEIGHT);\n\n// SETUP - RUNS ONCE AT PROGRAM START --------------------------------------\nfunction setup() {\n    for (let i = 0; i < N_GRAINS; i++) {  // For each sand grain...\n        grain.push(new Grain(0, 0, 0, 0));\n        let j = 0;\n        do {\n            grain[i].x = randint(0, (WIDTH << 8) - 1); // Assign random position within\n            grain[i].y = randint(0, (HEIGHT << 8) - 1); // the 'grain' coordinate space\n            // Check if corresponding pixel position is already occupied...\n            for (j = 0; (j < i) && (((grain[i].x >> 8) != (grain[j].x >> 8)) ||\n                ((grain[i].y >> 8) != (grain[j].y >> 8))); j++);\n        } while (j < i); // Keep retrying until a clear spot is found\n        imgbuf[(grain[i].y >> 8) * WIDTH + (grain[i].x >> 8)] = 0xff; // Mark it\n        grain[i].vx = grain[i].vy = 0; // Initial velocity is zero\n    }\n}\nsetup();\n// MAIN LOOP - RUNS ONCE PER FRAME OF ANIMATION ----------------------------\n\ngame.onUpdate(function () {\n    // Limit the animation frame rate to MAX_FPS.  Because the subsequent sand\n    // calculations are non-deterministic (don't always take the same amount\n    // of time, depending on their current states), this helps ensure that\n    // things like gravity appear constant in the simulation.\n\n    // Read accelerometer...\n    let ax = controller.acceleration(ControllerDimension.X) >> 8;\n    let ay = -controller.acceleration(ControllerDimension.Y) >> 8;\n    let az = Math.idiv(Math.abs(controller.acceleration(ControllerDimension.Z)), 2048);\n    az = (az >= 3) ? 1 : 4 - az;      // Clip & invert\n    ax -= az;                         // Subtract motion factor from X, Y\n    ay -= az;\n    let az2 = az * 2 + 1;         // Range of random motion to add back in\n\n    // ...and apply 2D accel vector to grain velocities...\n    let v2; // Velocity squared\n    let v;  // Absolute velocity\n    for (let i = 0; i < N_GRAINS; i++) {\n        const graini = grain[i];\n        graini.vx += ax + randint(0, az2); // A little randomness makes\n        graini.vy += ay + randint(0, az2); // tall stacks topple better!\n        // Terminal velocity (in any direction) is 256 units -- equal to\n        // 1 pixel -- which keeps moving grains from passing through each other\n        // and other such mayhem.  Though it takes some extra math, velocity is\n        // clipped as a 2D vector (not separately-limited X & Y) so that\n        // diagonal movement isn't faster\n        v2 = graini.vx * graini.vx + graini.vy * graini.vy;\n        if (v2 > 65536) { // If v^2 > 65536, then v > 256\n            //v = Math.sqrt(v2) | 0; // Velocity vector magnitude\n            // sqrt expensive on hw\n            v = Math.max(graini.vx, graini.vy);\n            graini.vx = Math.idiv(graini.vx, v) >> 8; // Maintain heading\n            graini.vy = Math.idiv(graini.vy, v) >> 8; // Limit magnitude\n        }\n    }\n\n    // ...then update position of each grain, one at a time, checking for\n    // collisions and having them react.  This really seems like it shouldn't\n    // work, as only one grain is considered at a time while the rest are\n    // regarded as stationary.  Yet this naive algorithm, taking many not-\n    // technically-quite-correct steps, and repeated quickly enough,\n    // visually integrates into something that somewhat resembles physics.\n    // (I'd initially tried implementing this as a bunch of concurrent and\n    // \"realistic\" elastic collisions among circular grains, but the\n    // calculations and volument of code quickly got out of hand for both\n    // the tiny 8-bit AVR microcontroller and my tiny dinosaur brain.)\n\n    for (let i = 0; i < N_GRAINS; i++) {\n        const graini = grain[i];\n        let newx = graini.x + graini.vx; // New position in grain space\n        let newy = graini.y + graini.vy;\n        if (newx > MAX_X) {               // If grain would go out of bounds\n            newx = MAX_X;          // keep it inside, and\n            graini.vx = - graini.vx >> 1;             // give a slight bounce off the wall\n        } else if (newx < 0) {\n            newx = 0;\n            graini.vx = - graini.vx >> 1;\n        }\n        if (newy > MAX_Y) {\n            newy = MAX_Y;\n            graini.vy = - graini.vy >> 1;\n        } else if (newy < 0) {\n            newy = 0;\n            graini.vy = - graini.vy >> 1;\n        }\n\n        let oldidx = (graini.y >> 8) * WIDTH + (graini.x >> 8); // Prior pixel #\n        let newidx = (newy >> 8) * WIDTH + (newx >> 8); // New pixel #\n        if ((oldidx != newidx) && // If grain is moving to a new pixel...\n            imgbuf[newidx]) {       // but if that pixel is already occupied...\n            let delta = Math.abs(newidx - oldidx); // What direction when blocked?\n            if (delta == 1) {            // 1 pixel left or right)\n                newx = graini.x;  // Cancel X motion\n                graini.vx = -graini.vx >> 1;          // and bounce X velocity (Y is OK)\n                newidx = oldidx;      // No pixel change\n            } else if (delta == WIDTH) { // 1 pixel up or down\n                newy = graini.y;  // Cancel Y motion\n                graini.vy = -graini.vy >> 1;          // and bounce Y velocity (X is OK)\n                newidx = oldidx;      // No pixel change\n            } else { // Diagonal intersection is more tricky...\n                // Try skidding along just one axis of motion if possible (start w/\n                // faster axis).  Because we've already established that diagonal\n                // (both-axis) motion is occurring, moving on either axis alone WILL\n                // change the pixel index, no need to check that again.\n                if ((Math.abs(graini.vx) - Math.abs(graini.vy)) >= 0) { // X axis is faster\n                    newidx = (graini.y >> 8) * WIDTH + (newx >> 8);\n                    if (!imgbuf[newidx]) { // That pixel's free!  Take it!  But...\n                        newy = graini.y; // Cancel Y motion\n                        graini.vy = - graini.vy >> 1;         // and bounce Y velocity\n                    } else { // X pixel is taken, so try Y...\n                        newidx = (newy >> 8) * WIDTH + (graini.x >> 8);\n                        if (!imgbuf[newidx]) { // Pixel is free, take it, but first...\n                            newx = graini.x; // Cancel X motion\n                            graini.vx = - graini.vx >> 1;         // and bounce X velocity\n                        } else { // Both spots are occupied\n                            newx = graini.x; // Cancel X & Y motion\n                            newy = graini.y;\n                            graini.vx = - graini.vx >> 1;         // Bounce X & Y velocity\n                            graini.vy /= - graini.vy >> 1;\n                            newidx = oldidx;     // Not moving\n                        }\n                    }\n                } else { // Y axis is faster, start there\n                    newidx = (newy >> 8) * WIDTH + (graini.x >> 8);\n                    if (!imgbuf[newidx]) { // Pixel's free!  Take it!  But...\n                        newx = graini.x; // Cancel X motion\n                        graini.vy = - graini.vy >> 1;         // and bounce X velocity\n                    } else { // Y pixel is taken, so try X...\n                        newidx = (graini.y >> 8) * WIDTH + (newx >> 8);\n                        if (!imgbuf[newidx]) { // Pixel is free, take it, but first...\n                            newy = graini.y; // Cancel Y motion\n                            graini.vy = - graini.vy >> 1;         // and bounce Y velocity\n                        } else { // Both spots are occupied\n                            newx = graini.x; // Cancel X & Y motion\n                            newy = graini.y;\n                            graini.vx = - graini.vx >> 1;         // Bounce X & Y velocity\n                            graini.vy = - graini.vy >> 1;\n                            newidx = oldidx;     // Not moving\n                        }\n                    }\n                }\n            }\n        }\n        graini.x = newx; // Update grain position\n        graini.y = newy;\n        imgbuf[oldidx] = 0;    // Clear old spot (might be same as new, that's OK)\n        imgbuf[newidx] = 0xff;  // Set new spot\n    }\n});\n\ngame.onPaint(function () {\n    for (let x = 0; x < WIDTH; ++x) {\n        const xs = x * GRAIN_RADIUS;\n        for (let y = 0; y < HEIGHT; ++y) {\n            const ys = y * GRAIN_RADIUS;\n            if (imgbuf[y * WIDTH + x])\n                screen.drawImage(grainImg, xs, ys)\n        }\n    }\n})","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"animated sand\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"controller\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"preferredEditor\": \"blocksprj\",\n    \"languageRestriction\": \"no-blocks\",\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1743828462433}